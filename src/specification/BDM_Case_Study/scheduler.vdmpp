class Scheduler

types


instance variables
    jobCatalogue: set of Job := {};
    employeeCatalogue: set of Employee := {};
    scheduleGLobal: map Employee to Job := {|->};

operations

public CreateSchedule: () ==> ()
CreateSchedule() ==
(
    let employee in set employeeCatalogue be st MatchingJobExists(employee,jobCatalogue) in 
    (
        dcl employeeSkills: map seq of char to nat := employee.GetSkills();
        let job in set jobCatalogue be st (job.GetSkill() in set dom employeeSkills) and
        (employee.GetTimeUnitsAvailable() >= job.GetTimeUnit()) and
        (MatchingSkillLevelExists(employee.GetSkills(),job))
        in 
        (
        job.SetTimeUnits(employee.GetTimeUnitsAvailable());
        jobCatalogue := {sjob | sjob in set jobCatalogue & job.GetTimeUnit() > 0};
        employee.SetTimeUnits(job.GetTimeUnit());
        employeeCatalogue := {semployee | semployee in set employeeCatalogue & employee.GetTimeUnitsAvailable() > 0};
        scheduleGLobal := scheduleGLobal ++ {employee |-> job};
        )
            
    );
);


public ScheduleSatisfied: () ==> seq of char
ScheduleSatisfied() ==
(
    /* dcl temp : nat := 0;
    for all job in set jobCatalogue
    do 
    (
        temp := temp + job.GetTimeUnit() ;
    );
    if temp > 0 then return "Not satisfied" else return "Satisfied"; */
    if exists job in set jobCatalogue & job.GetTimeUnit() > 0 then return "Not satisfied" else return "Satisfied";
);

public FindMatchingJob: Employee * set of Job ==> Job
FindMatchingJob(employee,jobs) ==
(
    dcl employeeSkills: map seq of char to nat := employee.GetSkills();
    let j in set jobs be st (j.GetSkill() in set dom employeeSkills)
    in
    return j
);





public AddJob: Job ==> ()
AddJob(pJob) ==
(
    jobCatalogue := jobCatalogue union {pJob};
)
pre pJob.GetId() not in set {job.GetId() | job in set jobCatalogue};

public AddEmployee: Employee ==> ()
AddEmployee(pEmployeee) ==
(
    employeeCatalogue := employeeCatalogue union {pEmployeee};
)
pre pEmployeee.GetId() not in set {employee.GetId() | employee in set employeeCatalogue};

pure public GetJobCatalogue: () ==> set of Job
GetJobCatalogue() ==
return jobCatalogue;    

pure public GetEmployeeCatalogue: () ==> set of Employee
GetEmployeeCatalogue() ==
return employeeCatalogue;    

pure public GetSchedule:() ==>  map Employee to Job
GetSchedule() ==
return scheduleGLobal;
 



functions
public JobExists: nat * set of Job -> bool
JobExists(id,jobCatalogue) ==
exists j in set jobCatalogue & j.GetId() = id;

public EmployeeExists: nat * set of Employee -> bool
EmployeeExists(id,employeeCatalogue) ==
exists e in set employeeCatalogue & e.GetId() = id;

public MatchingJobExists: Employee * set of Job -> bool
MatchingJobExists(employee, jobs) ==
    (exists job in set jobs & job.GetSkill() in set dom employee.GetSkills());
    
public MatchingSkillLevelExists: map seq of char to nat * Job -> bool
MatchingSkillLevelExists(employeeSkills,job) ==
    (exists skill in set dom employeeSkills & employeeSkills(skill) >= job.GetSkillLevel());

end Scheduler